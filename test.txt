using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

public class DailyFile
{
    public string FileName { get; set; }
    public DateTime FileDate { get; private set; }
    public string TTime { get; private set; }

    public DailyFile(string filename)
    {
        FileName = filename;
        TTime = "";

        try
        {
            var fn = Path.GetFileName(filename);
            var parts = fn.Split('.');
            var datePart = parts.First(p => p.StartsWith("D")).Substring(1); // e.g. "250330"
            FileDate = DateTime.ParseExact(datePart, "yyMMdd", CultureInfo.InvariantCulture);

            var timePart = parts.First(p => p.StartsWith("T")).Substring(1);
            TTime = timePart;
        }
        catch
        {
            FileDate = DateTime.MinValue;
            TTime = "";
        }
    }
}

public class RecordProcessor
{
    public static Dictionary<string, List<string>> ProcessFiles(List<DailyFile> files)
    {
        // Global dictionary of best blocks across all files
        var globalBest = new Dictionary<string, (string FileName, DateTime FileDate, int SequenceOrder, List<string> Block, DateTime EffectiveDate)>(StringComparer.OrdinalIgnoreCase);

        // Keep invalid blocks separately per file
        var invalidBlocksPerFile = new Dictionary<string, List<List<string>>>(StringComparer.OrdinalIgnoreCase);

        for (int fileIndex = 0; fileIndex < files.Count; fileIndex++)
        {
            var file = files[fileIndex];
            var lines = File.ReadAllLines(file.FileName);

            // Stage 1: Deduplicate valid blocks within this file
            var localBest = new Dictionary<string, (List<string> Block, DateTime EffectiveDate, int EntryOrderInFile)>(StringComparer.OrdinalIgnoreCase);

            List<string> currentBlock = null;
            string currentDtsId = null;
            DateTime currentEffectiveDate = DateTime.MinValue;
            int entryCounter = 0;

            foreach (var line in lines)
            {
                if (line.StartsWith("DTS"))
                {
                    // finalize previous block
                    if (currentBlock != null && currentDtsId != null)
                    {
                        if (currentEffectiveDate == DateTime.MinValue)
                        {
                            // invalid block → keep separately
                            if (!invalidBlocksPerFile.ContainsKey(file.FileName))
                                invalidBlocksPerFile[file.FileName] = new List<List<string>>();
                            invalidBlocksPerFile[file.FileName].Add(currentBlock);
                        }
                        else
                        {
                            if (!localBest.ContainsKey(currentDtsId))
                            {
                                localBest[currentDtsId] = (currentBlock, currentEffectiveDate, entryCounter);
                            }
                            else
                            {
                                var existing = localBest[currentDtsId];
                                if (currentEffectiveDate > existing.EffectiveDate ||
                                    (currentEffectiveDate == existing.EffectiveDate && entryCounter > existing.EntryOrderInFile))
                                {
                                    localBest[currentDtsId] = (currentBlock, currentEffectiveDate, entryCounter);
                                }
                            }
                        }
                    }

                    // start new block
                    entryCounter++;
                    currentBlock = new List<string> { line };
                    currentDtsId = line.Split(' ', StringSplitOptions.RemoveEmptyEntries)[0];

                    // parse effective date
                    var lastToken = line.Split(' ', StringSplitOptions.RemoveEmptyEntries).LastOrDefault() ?? "";
                    string rawDate = lastToken.Length >= 8 ? lastToken.Substring(0, 8) : "";
                    DateTime parsedDate;
                    bool validDate = DateTime.TryParseExact(rawDate, "yyyyMMdd",
                        CultureInfo.InvariantCulture, DateTimeStyles.None, out parsedDate);

                    currentEffectiveDate = validDate ? parsedDate : DateTime.MinValue;
                }
                else if (currentBlock != null)
                {
                    currentBlock.Add(line);
                }
            }

            // finalize last block
            if (currentBlock != null && currentDtsId != null)
            {
                if (currentEffectiveDate == DateTime.MinValue)
                {
                    if (!invalidBlocksPerFile.ContainsKey(file.FileName))
                        invalidBlocksPerFile[file.FileName] = new List<List<string>>();
                    invalidBlocksPerFile[file.FileName].Add(currentBlock);
                }
                else
                {
                    if (!localBest.ContainsKey(currentDtsId))
                    {
                        localBest[currentDtsId] = (currentBlock, currentEffectiveDate, entryCounter);
                    }
                    else
                    {
                        var existing = localBest[currentDtsId];
                        if (currentEffectiveDate > existing.EffectiveDate ||
                            (currentEffectiveDate == existing.EffectiveDate && entryCounter > existing.EntryOrderInFile))
                        {
                            localBest[currentDtsId] = (currentBlock, currentEffectiveDate, entryCounter);
                        }
                    }
                }
            }

            // Stage 2: Merge local best into global best
            foreach (var kvp in localBest)
            {
                string dtsId = kvp.Key;
                var block = kvp.Value.Block;
                var effDate = kvp.Value.EffectiveDate;

                if (!globalBest.ContainsKey(dtsId))
                {
                    globalBest[dtsId] = (file.FileName, file.FileDate, fileIndex, block, effDate);
                }
                else
                {
                    var existing = globalBest[dtsId];
                    if (effDate > existing.EffectiveDate ||
                        (effDate == existing.EffectiveDate && file.FileDate > existing.FileDate) ||
                        (effDate == existing.EffectiveDate && file.FileDate == existing.FileDate && fileIndex > existing.SequenceOrder))
                    {
                        globalBest[dtsId] = (file.FileName, file.FileDate, fileIndex, block, effDate);
                    }
                }
            }
        }

        // Build final result list: dictionary mapping fileName → merged lines
        var resultFiles = new Dictionary<string, List<string>>();
        foreach (var group in globalBest.Values.GroupBy(r => r.FileName))
        {
            var mergedLines = new List<string>();
            foreach (var record in group)
            {
                mergedLines.AddRange(record.Block);
            }

            // add invalid blocks too
            if (invalidBlocksPerFile.ContainsKey(group.Key))
            {
                foreach (var invalidBlock in invalidBlocksPerFile[group.Key])
                {
                    mergedLines.AddRange(invalidBlock);
                }
            }

            resultFiles[group.Key] = mergedLines;
        }

        // Add empty files (those that lost all valid blocks but may have invalid ones)
        foreach (var file in files)
        {
            if (!resultFiles.ContainsKey(file.FileName))
            {
                var mergedLines = new List<string>();
                if (invalidBlocksPerFile.ContainsKey(file.FileName))
                {
                    foreach (var invalidBlock in invalidBlocksPerFile[file.FileName])
                    {
                        mergedLines.AddRange(invalidBlock);
                    }
                }
                resultFiles[file.FileName] = mergedLines;
            }
        }

        return resultFiles;
    }
}
