var bestRecords = new Dictionary<string, (string FileName, DateTime FileDate, int SequenceOrder, List<string> Block, DateTime EffectiveDate)>(StringComparer.OrdinalIgnoreCase);

for (int fileIndex = 0; fileIndex < files.Count; fileIndex++)
{
    var file = files[fileIndex];
    var lines = File.ReadAllLines(file.FileName);

    List<string> currentBlock = null;
    string currentDtsId = null;
    DateTime currentEffectiveDate = DateTime.MinValue;

    foreach (var line in lines)
    {
        if (line.StartsWith("DTS"))
        {
            // finalize previous block
            if (currentBlock != null && currentDtsId != null)
            {
                // compare and replace immediately
                if (!bestRecords.ContainsKey(currentDtsId))
                {
                    bestRecords[currentDtsId] = (file.FileName, file.FileDate, fileIndex, currentBlock, currentEffectiveDate);
                }
                else
                {
                    var existing = bestRecords[currentDtsId];
                    if (currentEffectiveDate > existing.EffectiveDate ||
                        (currentEffectiveDate == existing.EffectiveDate && file.FileDate > existing.FileDate) ||
                        (currentEffectiveDate == existing.EffectiveDate && file.FileDate == existing.FileDate && fileIndex > existing.SequenceOrder))
                    {
                        bestRecords[currentDtsId] = (file.FileName, file.FileDate, fileIndex, currentBlock, currentEffectiveDate);
                    }
                }
            }

            // start new block
            currentBlock = new List<string> { line };
            currentDtsId = line.Split(' ')[0]; // "DTS123"

            // parse effective date safely
            var lastToken = line.Split(' ', StringSplitOptions.RemoveEmptyEntries).Last();
            string rawDate = lastToken.Length >= 8 ? lastToken.Substring(0, 8) : "";
            DateTime parsedDate;
            currentEffectiveDate = DateTime.TryParseExact(rawDate, "yyyyMMdd", CultureInfo.InvariantCulture, DateTimeStyles.None, out parsedDate)
                ? parsedDate : DateTime.MinValue;
        }
        else if (currentBlock != null)
        {
            currentBlock.Add(line);
        }
    }

    // finalize last block
    if (currentBlock != null && currentDtsId != null)
    {
        if (!bestRecords.ContainsKey(currentDtsId))
        {
            bestRecords[currentDtsId] = (file.FileName, file.FileDate, fileIndex, currentBlock, currentEffectiveDate);
        }
        else
        {
            var existing = bestRecords[currentDtsId];
            if (currentEffectiveDate > existing.EffectiveDate ||
                (currentEffectiveDate == existing.EffectiveDate && file.FileDate > existing.FileDate) ||
                (currentEffectiveDate == existing.EffectiveDate && file.FileDate == existing.FileDate && fileIndex > existing.SequenceOrder))
            {
                bestRecords[currentDtsId] = (file.FileName, file.FileDate, fileIndex, currentBlock, currentEffectiveDate);
            }
        }
    }
}

// ✅ Build final DailyFile list — only winning blocks per file
var resultFiles = new List<DailyFile>();
foreach (var group in bestRecords.Values.GroupBy(r => r.FileName))
{
    var df = new DailyFile(group.Key);
    var mergedLines = new List<string>();
    foreach (var record in group)
    {
        mergedLines.AddRange(record.Block);
    }
    df._originalMemberCount = mergedLines.Count;
    resultFiles.Add(df);
}

// Add empty files too
foreach (var file in files)
{
    if (!resultFiles.Any(f => f.FileName == file.FileName))
    {
        var emptyFile = new DailyFile(file.FileName);
        emptyFile._originalMemberCount = 0;
        resultFiles.Add(emptyFile);
    }
}
